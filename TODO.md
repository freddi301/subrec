# TODO

pattern checking (eval, (rules) (data) (term))

# WISHLIST

compiler/interpreter:
  infere if more efficient copy term or reference it (so garbage collected)
  infere from substitution rules possible pattern matches into a more local code

implement other language's cool features
  Go, Rust, Haxe
  Clojure, Lisp, Scheme, Racket
  Haskell, OCaml, F#
  Java, C#, SmallTalk, ObjectiveC
  JavaScript (TypeScript, Flow, Elm, CoffeeScript), Python, Ruby (Crystal)
  Erlang, Elixir
  Lua, Rebol
  R, Julia, Matlab
  Swift, Scala, FORTH, Fortran, Rexx, Perl, Pascal, Algol, Bash, Basic, awk, PHP, Hack, Dart, Kotlin,
  Visual Basic, VimScript, ASP, Vala, ColdFusion, ActionScript, AppleScript, Prolog, Delphi, Nim, Nemerle,
  PureScript, Eiffel, Ada, Logos, Gosu, Apex, Idl, ABL, Lasso, APL, J, ML, Octave, Joy, Cobol, Deplhi, Red, K,
  Ceylon, ParaSail, Idris, Q, Pure, Genie, Agda, Cobra, Seed7, Boo, Squirrel, Falcon, Factor, Io, D, JoinJava,
  Wren, agora, Lux, gravity, cpython, ponyc, nu, amber, lily, Groovy, FP, FL, Dylan, Algol,


static typing
interfaces
hygienic macros
generics
traits
parametric polymorphism
ad hoc polymorphism
multimethods
runtime polymorphism
row polymorphism
symple dsl
ADT
GADT
common data types (eg. number, list, set, dict, map, tuple, bit)
seamless async
seamless lazy evaluation
do notatation (from haskell)
subtyping
threading fibers (go like)
must have libraries (date manipulation, JSON manipulation)
effectful non-blocking IO
seamless distributed programming (erlang like)
list comprehension
seamless parallel programming (with some monoid structures)
currying
lambdas
coroutines (python like)
programming in the large:
  documentation
  semantic versioning automatically enforced (elm like)
  distribution
  package system
  namespaces
  visibility
ide suppport
